#!/bin/bash

export LANG="C"
export LC_ALL="C"

GEM_RE='([^0-9].*)-([0-9].*)'

readonly currdir="$PWD"
export PATH="$PATH:/sbin:/usr/sbin:/usr/local/sbin"
declare -A DEV_BRANCHES DEV_REMOTE_SOURCES DEV_REMOTE_BRANCHES DEV_ORIGIN_TYPES
declare -a DEV_REMOTES

# The key -> value mapping in DEV_BRANCHES defines child -> parent relations
# between branches.  A branch is considered a root branch if it has itself
# as a parent.
DEV_BRANCHES["master"]="master"
DEV_BRANCHES["openstack-os-build"]="master"
DEV_BRANCHES["hadoop-os-build"]="master"
DEV_BRANCHES["openstack-build"]="openstack-os-build"
DEV_BRANCHES["hadoop-build"]="hadoop-os-build"

# DEV_REMOTE_SOURCES defines the source parts of the URLs that the
# various remotes map to.  The "personal" remote is not listed in this
# hash, and most of the script assumes that origin always points at
# github and that the personal remote should be used as a backup target 
# for all branches that were pulled from origin.
DEV_REMOTE_SOURCES["origin"]="https://github.com/dellcloudedge/"
DEV_REMOTE_SOURCES["dell"]="ssh://gitolite@10.9.244.31/"

# DEV_REMOTE_BRANCHES defines what branches in the main Crowbar repository
# should be pulled and synced with what remotes.
# Barclamps do care about remote branches.
DEV_REMOTE_BRANCHES["origin"]="master openstack-os-build hadoop-os-build"
DEV_REMOTE_BRANCHES["dell"]="openstack-build hadoop-build"

# DEV_REMOTES holds the remotes we will work on in the order they should be
# worked on when ordering matters.
DEV_REMOTES=("origin" "dell")

# Source our config file if we have one
[[ -f $HOME/.build-crowbar.conf ]] && \
    . "$HOME/.build-crowbar.conf"

# Look for a local one.
[[ -f build-crowbar.conf ]] && \
    . "build-crowbar.conf"

# Set up our proxies if we were asked to.
if [[ $USE_PROXY = "1" && $PROXY_HOST ]]; then
    proxy_str="http://"
    if [[ $PROXY_PASSWORD && $PROXY_USER ]]; then
	proxy_str+="$PROXY_USER:$PROXY_PASSWORD@"
    elif [[ $PROXY_USER ]]; then
	proxy_str+="$PROXY_USER@"
    fi
    proxy_str+="$PROXY_HOST"
    [[ $PROXY_PORT ]] && proxy_str+=":$PROXY_PORT"
    [[ $no_proxy ]] || no_proxy="localhost,localhost.localdomain,127.0.0.0/8,$PROXY_HOST" 
    [[ $http_proxy ]] || http_proxy="$proxy_str/" 
    [[ $https_proxy ]] || https_proxy="$http_proxy"
    export no_proxy http_proxy https_proxy
else
    unset no_proxy http_proxy https_proxy
fi

[[ $DEV_AVAILABLE_REMOTES ]] && DEV_REMOTES=($DEV_AVAILABLE_REMOTES) 

# Location of the Crowbar checkout we are building from.
[[ $CROWBAR_DIR ]] || CROWBAR_DIR="${0%/*}"
[[ $CROWBAR_DIR = /* ]] || CROWBAR_DIR="$currdir/$CROWBAR_DIR"
[[ -f $CROWBAR_DIR/build_crowbar.sh && -d $CROWBAR_DIR/.git ]] || \
    die "$CROWBAR_DIR is not a git checkout of Crowbar!" 
export CROWBAR_DIR

. "$CROWBAR_DIR/build_lib.sh" || exit 1
trap - 0 INT QUIT TERM

which gem &>/dev/null || \
    die "Rubygems not installed, and some of our helpers need a JSON gem."

gem list -i json &>/dev/null || \
    die "JSON gem not installed.  Please install it with gem install json."

set -o pipefail

# If we have openstack-os-build and hadoop-os-build brancehs locally,
# let the merge engine know about them.

for branch in openstack-os-build hadoop-os-build; do
    [[ ${DEV_BRANCHES[$branch]} ]] && continue
    in_repo branch_exists "$branch" || continue
done

# Sanity-check our dependency hash
for branch in "${!DEV_BRANCHES[@]}"; do
    in_repo branch_exists "$branch" || \
	die "$branch is specified in \$DEV_BRANCHES, but does not exist!"
    in_repo branch_exists "${DEV_BRANCHES[$branch]}" || \
	die "${DEV_BRANCHES[$branch]} dies not exist, but it is specified as the parent of $branch!"
done

# Given a branch, echo all the child branches for this 
# branch in the current release.
child_branches() {
    local p=${1#$DEV_BRANCH_PREFIX} b
    for b in "${!DEV_BRANCHES[@]}"; do 
	[[ ${DEV_BRANCHES[$b]} && \
	    ${DEV_BRANCHES[$b]} != $b && \
	    ${DEV_BRANCHES[$b]} = $p ]] || continue
	echo "$DEV_BRANCH_PREFIX$b"
    done
    return 0
}

# Given a branch, echo its parent in the current release.
parent_branch() {
    local p="${DEV_BRANCHES[${1##*/}]}"
    if [[ $p && $p != ${1##*/} ]]; then
	echo "${DEV_BRANCH_PREFIX}${p}"
	return 0
    fi
    return 1
}

# Echo all of the root branches in the current release.
root_branches() {
    local b
    for b in "${!DEV_BRANCHES[@]}"; do
	[[ $b = ${DEV_BRANCHES[$b]} ]] || continue
	echo "${DEV_BRANCH_PREFIX}$b"
    done
    return 0
}

ordered_branches() {
    # $@ = branches to print all of the children of.
    [[ $@ ]] && local branches=("$@") || local branches=("$(root_branches)")
    local b children=()
    printf "%s\n" "${branches[@]}"
    for b in "${branches[@]}"; do
	children=($(child_branches "$b"))
	[[ $children ]] && ordered_branches "${children[@]}"
    done
}

# Given a branch, print the first remote that branch is "owned" by
remote_for_branch() {
    local remote
    for remote in "${DEV_REMOTES[@]}"; do
	is_in "$1" "${DEV_REMOTE_BRANCHES[$remote]}" || continue
	echo "$remote"
	return 0
    done
    return 1
}

# Given a remote and a list of branches,
# return just the branches that are in that remote.
filter_branches_for_remote() {
    local remote="$1" b
    shift
    for b in "$@"; do
	is_in "${b##*/}" "${DEV_REMOTE_BRANCHES[$remote]}" || continue
	echo "$b"
    done
}
    
# Test to see if a specific repository is clean.
# Ignores submodules and unchecked-in directories that are git repositories.
git_is_clean() {
    local line hpath ret=0
    while read line; do
	case $line in
	    # Untracked file.  Ignore it if it is also a git repo, 
	    # complain otherwise.
	    '??'*) hpath=${line%% ->*}
                   hpath=${hpath#* }
		   [[ -d $hpath && -d $hpath.git ]] && continue
                   ret=1;;
	    '') continue;;
	    *) ret=1;
	esac
    done < <(git status --porcelain --ignore-submodules)
    [[ $ret = 0 ]] && return
    git status
    [[ $IGNORE_CLEAN ]] && return 0
    return 1
}

# Get the current release we are working on, which is a function of
# the currently checked-out branch.
current_release() {
    local ans="$(in_repo git symbolic-ref HEAD)" || \
	die "current_release: Cannot get current branch information!"
    ans=${ans#refs/heads/}
    case $ans in
	personal/*) continue;;
	stable/*) echo "stable";;
	release/*)
	    ans="${ans#release/}"
	    echo "${ans%%/*}";;
	*) echo "development";;
    esac
}

# Test to see if a barclamp is clean.
barclamp_is_clean() { in_barclamp "$1" git_is_clean; }

# Test to see if all our barclamps are clean.
barclamps_are_clean() {
    local bc
    for bc in "$CROWBAR_DIR/barclamps/"*; do
	is_barclamp "${bc##*/}" || continue
	(cd "$bc"; git_is_clean) || return 1
    done
}

# Test to see if all the Crowbar repositories are clean.
crowbar_is_clean() { barclamps_are_clean && in_repo git_is_clean; }

# Get a list of all the barclamps that a specific branch refers to.
barclamps_in_branch() {
    local b res=()
    for b in "$@"; do
	in_repo branch_exists "$b" || \
	    die "Branch $b does not exist in the Crowbar repo!"
    done
    local res=($(for b in "$@"; do in_repo git ls-tree -r \
	"$b" barclamps; done | \
	awk '/160000 commit/ {print $4}' |sort -u))
    printf "%s\n" "${res[@]#barclamps/}"
}

# Get the list of barclamps that originate from this branch.  
# $1 must be a branch name, and it must be some sort of release branch.
barclamps_from_branch() {
    # $1 = branch in Crowbar.
    is_in "${1##*/}" "${!DEV_BRANCHES[*]}" || \
	die "Will not be able to determine parent of $1."
    # If we don't have a parent branch, we are one of the roots.
    local parent=$(parent_branch "$1")
    if [[ ! $parent ]]; then
	barclamps_in_branch "$1"
	return 0
    fi
    sort <(barclamps_in_branch "$1") <(barclamps_in_branch "$parent") |uniq -u
}

# Fetch (but do not merge) updates from all our remotes, in both the
# main Crowbar repository and the barclamps.
fetch_all() {
    local remote barclamp b
    for remote in "${DEV_REMOTES[@]}"; do
        debug "Fetching $remote"
	in_repo git fetch "$remote" || continue
	for b in ${DEV_REMOTE_BRANCHES[$remote]}; do
	    for barclamp in $(barclamps_from_branch "${DEV_RELEASE_PREFIX}$b"); do
		debug "Fetching $barclamp"
		in_barclamp "$barclamp" git fetch origin || \
		    die "Cound not fetch updates for $barclamp"
	    done
	done
    done
}

# Helper function for calling curl to talk to github.
curl_and_res() {
    curl "$@"
    case $? in
	0) return 0;;
	7) echo "Unable to contact Github, please try again later." >&2
	    return 1;;
	22) return 1;;
	*) echo "Curl reported error ${?}!." >&2
	    return 1;;
    esac
}

[[ ( $DEV_GITHUB_ID && $DEV_GITHUB_PASSWD) || $1 = setup ]] || \
    die "dev has not been configured. Please run $CROWBAR_DIR/dev setup first."

# Fork a repository on Github.
github_fork() {
    # $1 = user to fork from
    # $2 = repo to fork
    curl_and_res -f -u "$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD" -X POST \
	"https://api.github.com/repos/$1/$2/forks" >&/dev/null || \
	die "Could not fork $1/$2!"
}

# Perform initial setup.  If you make any changes to this function, take
# care to make sure it stays idempotent.
setup() {
    local p
    crowbar_is_clean &>/dev/null || \
    	die "Crowbar repo must be clean before trying to set things up!"
    [[ $DEV_GITHUB_ID && $DEV_GITHUB_PASSWD ]] || {
	read -p "Enter your Github username: " DEV_GITHUB_ID
	curl_and_res -f \
	    "https://api.github.com/users/$DEV_GITHUB_ID" &>/dev/null || \
	    die "Could not verify that $DEV_GITHUB_ID is a valid Github user.."
	while [[ $p != $DEV_GITHUB_PASSWD || ! $p ]]; do
	    [[ $p ]] && echo "Passwords did not match, try again."
	    read -s -p "Enter your Github password: " DEV_GITHUB_PASSWD
	    echo
	    read -s -p "Enter your Github password again: " p
	    echo
	done
	curl_and_res -f -u "$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD" \
	    https://api.github.com/user &>/dev/null || {
	    echo "Unable to authenticate with Github as user $DEV_GITHUB_ID." >&2
	    die "Please try again when you have Github access."
	}
	echo "DEV_GITHUB_ID=\"$DEV_GITHUB_ID\"" >> "$HOME/.build-crowbar.conf"
	echo "DEV_GITHUB_PASSWD=\"$DEV_GITHUB_PASSWD\"" >> "$HOME/.build-crowbar.conf"
    }

    echo "Finding Github repos..."
    local repos=($(
	    eval "$(curl -f -u "$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD" \
		https://api.github.com/user/repos 2>/dev/null | \
		parse_yml_or_json - name)" 
	    echo "${name[@]}"))
    if ! is_in crowbar "${repos[*]}"; then
	echo "Creating your fork of Crowbar on Github."
	github_fork dellcloudedge crowbar || die "Unable to create your fork of Crowbar."
    fi
    if ! in_repo git config --get remote.personal.url &>/dev/null; then
	echo "Adding remote for personal fork of crowbar on Github."
	in_repo git remote add personal \
	    "https://$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD@github.com/$DEV_GITHUB_ID/crowbar.git"
	in_repo git fetch personal || \
	    die "Cannot fetch repository info for your Crowbar fork on Github!"
	in_repo git remote set-head -a personal
    fi
    
    for b in ${DEV_REMOTE_BRANCHES["origin"]}; do
	in_repo git checkout "$b" || \
	    die "Cannot checkout $b"
	in_repo git merge -q "origin/$b" || \
	    die "Cannot merge origin/$b into $b"
	in_repo git submodule update --init || \
	    die "Cannot check out submodules for branch $b"
	in_repo git submodule sync || \
	    die "Cannot sync origin URLs for branch $b"
    done
    in_repo git checkout master
    for b in $(barclamps_in_branch ${DEV_REMOTE_BRANCHES["origin"]}); do
	(   cd "$CROWBAR_DIR/barclamps/$b"
	    repo="$(git config --get remote.origin.url)"
	    [[ $repo =~ /dellcloudedge/ ]] || continue
	    repo="${repo##*/}"
	    repo="${repo%.git}"
	    is_in "$repo" "${repos[*]}" || \
		github_fork dellcloudedge "$repo" || \
		die "Could not create a personal fork of $repo"
	    if ! git config --get remote.personal.url &>/dev/null; then
		git remote add personal \
		    "https://$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD@github.com/$DEV_GITHUB_ID/$repo.git"
		in_repo git fetch personal || \
		    die "Cannot fetch repositroy info for your fork of $repo on Github."
		in_repo git remote set-head -a personal
	    fi
	) || exit 1
    done
}

# Test repository $1 to see if commit $2 is in sync with $3.
# In this case, "in sync" is defined as:
#  * $2 and $3 point at the same commit, or
#  * There are no commits in the set of all commits reachable from $3 that
#    are not also reachable from $2.
remote_branches_synced() {
    # $1 = repository to operate in
    # $2 = local branch to test
    # $3 = remote branch to test
    [[ -d $1/.git ]] || \
	die "remote_branches_synced: $1 is not a git repo"
    [[ $VERBOSE2 ]] && echo "Checking to see if out of sync: $2 $3"
    (cd "$1"; git rev-parse --verify -q "$2" &>/dev/null) || \
	return 1
    (cd "$1"; git rev-parse --verify -q "$3" &>/dev/null) || \
	return 1
    # $2 and $3 resolve to the same commit, they are in sync.
    (cd "$1"; [[ $(git rev-parse "$2") = $(git rev-parse "$3") ]] ) && return 0
    # Test to see if there are any commits in $3 that are not
    # reachable from $2.  If there are, then the branches are not synced.
    (cd "$1"; [[ ! $(git rev-list "$2..$3") ]] ) && return 0
    return 1
}

# Back up our current commits to local branches in a barclamp that:
#  * Have a matching branch at origin, or
#  * Have a matching remote at personal.
github_backup() (
    local repo=$1 branches=() ref branch
    cd "$repo"
    while read ref branch; do
	branch="${branch#refs/heads/}"
		# If we have a ref for this branch on the personal remote
		# and the local branch does not contain any commits that 
		# the one on the personal remote does, then it is already
		# synced and we can skip the actual network communication.
	git rev-parse --verify -q \
	    refs/remotes/personal/$branch &>/dev/null && \
	    remote_branches_synced "." \
	    refs/remotes/personal/$branch refs/heads/$branch && \
	    continue
	branches+=("$branch")
    done < <(git show-ref --heads)
    if [[ $branches ]]; then
	echo "Pushing ${branches[*]} to personal barclamp ${repo##*/}" >&2
	git push -qf personal "${branches[@]}" || \
	    die "Could not push ${branches[*]} to personal barclamp ${repo##*/}"
    fi
)

# Back up our current commits to local branches in a barclamp by force-creating
# a new branch named personal/$DEV_GITHUB_ID/$branch for each branch, and then
# force-pushing the newly created or updated branch back to the origin remote.
generic_backup() (
    local repo="$1" branches=() branch ref 
    shift
    local prefix="refs/heads/personal/$DEV_GITHUB_ID"
    cd "$repo"
    if [[ $(git symbolic-ref HEAD) = "$prefix"/* ]]; then
	die "generic_backup: Personal branch currently checked out, cannot proceed."
    fi
    while read ref branch; do
	if [[ $branch = "$prefix"/* ]]; then
	    b=${branch#$prefix/}
	    branch_exists "$b" || git branch -D "$branch#refs/heads/"
	    continue
	fi
	branch=${branch#refs/heads/}
        branch_exists "personal/$DEV_GITHUB_ID/$branch" && \
	    [[ $(git rev-parse --verify -q "refs/remotes/origin/personal/$DEV_GITHUB_ID/$branch") && \
	    $(git rev-parse "refs/remotes/origin/personal/$DEV_GITHUB_ID/$branch") = \
	    $(git rev-parse "refs/heads/$branch") ]] && continue
	git branch -f "personal/$DEV_GITHUB_ID/$branch" "$branch"
	branches+=("personal/$DEV_GITHUB_ID/$branch")
    done < <(git show-ref --heads)
    if [[ $branches ]]; then
	echo "Pushing personal refs for ${branches[*]} to origin of barclamp ${repo##*/}"
	git push -qf origin "${branches[@]}"
    fi
)

# Back up any local commits that are not already present on our upstreams,
# or that have not already been backed up.
backup_everything() {
    local bc branch branches=() remote backup_func temp_branches=()
    for bc in "$CROWBAR_DIR/barclamps/"*; do
	[[ -d $bc && -d $bc/.git ]] || continue
	if in_barclamp "${bc##*/}" \
	    git config --get remote.personal.url &>/dev/null; then
	    github_backup "$bc" || die "Could not back up barclamp ${bc##*/}"
	else
	    generic_backup "$bc" || die "Could not back up barclamp ${bc##*/}"
	fi
    done
    if in_repo git config --get remote.personal.url &>/dev/null; then
	# Iterate through branches that were created just to track submodule
	# updates, and delete them if their references are contained in a
	# local branch -- this means they were merged, and can go away.
	while read ref branch; do
	    [[ $branch = refs/remotes/personal/pull-req* ]] || continue
	    [[ $(git branch --contains "$ref") ]] || continue
	    branches+=(":${branch#refs/remotes/personal/}")
	done < <(git show-ref)

	# Push branches that have been pushed to personal in the past
	while read ref branch; do
	    branch="${branch#refs/heads/}"
	    # If we do not have a ref for this branch on the personal remote
	    # or on the origin remote, this branch should not be backed up.
	    ( git rev-parse --verify -q \
		refs/remotes/personal/$branch &>/dev/null || \
		git rev-parse --verify -q \
		refs/remotes/origin/$branch &>/dev/null) || continue
	    # If this branch has a personal remote and the local branch 
            # does not contain any commits that the one on the personal 
	    # remote does, then it is already synced and we can skip 
	    # the actual network communication.
	    git rev-parse --verify -q \
		refs/remotes/personal/$branch &>/dev/null && \
		remote_branches_synced "." \
		refs/remotes/personal/$branch refs/heads/$branch && \
		continue
	    branches+=("$branch")
	done < <(git show-ref --heads)
	if [[ $branches ]]; then
	    echo "Pushing ${branches[*]} to personal Crowbar"
	    in_repo git push -qf personal "${branches[@]}" || \
	    	die "Could not push ${branches[*]} to personal Crowbar!"
	fi
	
    fi
}

# Merges in changes into all local branches from their upstreams.
# Assumes that upstream commits have already been fetched from the proper
# remotes by running dev fetch.
sync_repo() (
    local branch head b bc origin ref
    # $1 = dir to CD to initially.
    # Assumes that origin has already been fetched.
    cd "$1"
    # Repo is not clean, we will refuse to merge in any case.
    git_is_clean || {
	echo "$1 is not clean." >&2
	return 1
    }
    # Merge upstream branches from all origins, but only if the branch
    # is listed in DEV_REMOTE_BRANCHES for that origin, 
    # unless $origin is actually "origin"
    while read ref branch; do
	branch=${branch#refs/heads/}
	for origin in "${!DEV_REMOTE_BRANCHES[@]}"; do
            remote=$(git config branch.${branch}.remote)
	    [[ $origin = origin ]] || \
                [[ $remote ]] || \
		is_in "${branch##*/}" "${DEV_REMOTE_BRANCHES[$origin]}" || \
		continue
	    git rev-parse --verify -q "$origin/$branch" &>/dev/null || continue
	    remote_branches_synced "$1" "refs/heads/$branch" "refs/remotes/$origin/$branch" && continue
	    [[ $head ]] || head=$(git symbolic-ref HEAD) || {
	    # Oh, boy, we are in detached HEAD.
	    # Die with a possibly-helpful error message.
		echo "$1 has had commits to a detached HEAD." >&2
		echo "git submodule update probably left it in this state." >&2
		echo "It should probably be on ${DEV_BRANCH_PREFIX}master, but you need to fix it."
		return 1 
	    }
            debug "Checking out $branch"
	    git checkout "$branch" || {
		echo "$bc: Unable to checkout $branch!" >&2
		return 1
	    }
            debug "Merging $origin/$branch into $branch"
	    git merge -q "$origin/$branch" || {
		echo "$1: Unable to merge $origin/$branch into $branch, will unwind." >&2
		git reset --hard
		return 1
	    }
	done 
    done < <(git show-ref --heads)
    if [[ $head ]]; then git checkout "${head#refs/heads/}"; fi
)

# Recursivly merge all changes from a given branch into its children, if any.
# Parent -> child relations are defined by the structure of DEV_BRANCHES.
ripple_changes_out() {
    # $1 branch to ripple changes from. Changes will be rippled to all 
    # children of $1.
    local parent="$1" child
    in_repo git rev-parse --verify -q "$parent" &>/dev/null || \
	die "ripple_changes_out: $parent is not a branch in Crowbar!"
    for child in $(child_branches "$parent"); do
	in_repo git rev-parse --verify -q "$parent" &>/dev/null || \
	    die "ripple_changes_out: $child is not a branch in Crowbar!"
        debug "Testing $parent -> $child"
	remote_branches_synced "$CROWBAR_DIR" "refs/heads/$child" "refs/heads/$parent" && continue
	[[ $head ]] || head=$(in_repo git symbolic-ref HEAD) || \
	    die "Could not save the current branch!"
        debug "Checking out $child"
	[[ $(in_repo git symbolic-ref HEAD) = refs/heads/$child ]] || \
	    in_repo git checkout "$child"
        debug "Merging $parent into $child"
	in_repo git merge -q "$parent" || \
	    die "Merge $parent into $child branch of Crowbar failed."
	ripple_changes_out "$child"
    done
}

# Merge all changes from our upstreams for all barclamps and the main Crowbar
# repository, and then update the branches for the current release according
# to the branch structure defined in DEV_BRANCHES.
sync_everything() {
    local unsynced_barclamps=()
    local b u head res=0 ref branch rel
    crowbar_is_clean || \
	die "Will not try to sync local repo with origin when working tree is dirty."
    # Do barclamps first.
    for b in $(barclamps_in_branch ${DEV_REMOTE_BRANCHES[@]}); do
        debug "Syncing $b"
	sync_repo "$CROWBAR_DIR/barclamps/$b" && continue
	unsynced_barclamps+=("$b")
    done
    # Finished with barclamps, now for crowbar.
    debug "Syncing crowbar"
    sync_repo "$CROWBAR_DIR" || \
	die "Could not sync Crowbar with origin branches"
    # Now for the branch-rippling merges of doom
    for branch in $(root_branches); do
	ripple_changes_out "$branch"
    done
    [[ $head ]] && in_repo git checkout "${head#refs/heads/}"
    if [[ $unsynced_barclamps ]]; then
	echo "Unable to sync origin with current master in:" >&2
	echo "  ${unsynced_barclamps[*]}"
	res=1
    fi
    [[ $res = 0 ]] && return 0
    echo 
    echo "Please fix things up and rerun sync."
    return 1
}

dev_help () {
    cat <<EOF
$0: Development helper for Crowbar.

Command line options:

  setup -- Sets up your local Crowbar repositories for working with the 
           new Github regime.  This command will prompt for your Github
           login information, make sure you have local copies of all the
           barclamp repos that Crowbar references checked out, create personal
           forks of all the crowbar repos from the dellcloudedge account on
           github, and create the appropriate remotes needed for day-to-day
           operation.

  is_clean -- Check to see if the barclamps have everything committed
              with no untracked files, and check to see if the main
              Crowbar repository is clean while ignoring submodule references.

  fetch -- Fetch all changes from the dellcloudedge Crowbar repositories.
           Does not try to merge any changes into your local repository.
           You can run a fetch at any time without disturbing your working
           code, provided you have network connectivity.

  backup -- Push any locally committed changes in any repositories that were
            initially forked from dellcloudedge into your personal Github forks.
            You can run a backup at any time without disturbing your working
            code, provided you have network connectivity.

  sync -- Merge any changes that have been fetched into the current
          repositories.  dev is_clean should exit without any messages before
          running this command.

  push -- Unconditionally push a branch (or branches) to your crowbar Github
          fork.  Any arguments are interpreted as branch names to push, and
          if there are no arguments it pushes the branch you are currently on.
          Any branches pushed using this command will automatically be backed
          up when dev backup is run as well.

  pull-requests-prep -- Fetches, Syncs, and backs up all changes.  Then figures out
                        The set of barclamps and crowbar branches that need to have
                        pull requests created.  The output is a command line that can
                        be copied and executed.

  pull-requests-gen -- Creates a set of pull requests with similar ids and links based
                       upon the barclamps dependency trees.  These will be automatically
                       sent to Github for processing and review by others on the team.

  release -- Shows the current release that dev is operating on.

  releases -- Lists the releases to choose from.

  switch -- Change current release to the specified release.

  cut_release -- DO NOT USE UNLESS YOU KNOW WHAT YOU ARE DOING! Makes a new set
                 of branches and barclamp branches from the current release into
                 the new named release.  Must provide a unique new name.

EOF
}

# Tests to see if the given branch in a repo needs a pull request. 
branch_needs_pull_req() {
    # $1 = branch
    git rev-parse --verify -q "origin/$1" &>/dev/null || return 1 
    remote_branches_synced '.' "refs/remotes/origin/$1" \
	"refs/heads/$1" && return 1
    return 0
}

# Make sure everything is up to date, and then figure out what barclamps
# and branches need pull requests on Github.  Once we have that figured out,
# print out a command line that can be used by dev pull-requests-gen to
# actually generate the pull requests.
pull_requests_prep() {
    crowbar_is_clean && fetch_all && sync_everything && backup_everything || \
    	die "Unable to prepare for pull requests"
    local -A barclamps branches_to_push
    local barclamps_to_push=()
    local branch bc
    for branch in ${DEV_REMOTE_BRANCHES["origin"]}; do
	branch="${DEV_BRANCH_PREFIX}$branch"
	for bc in $(barclamps_from_branch "$branch"); do
	    in_barclamp "$bc" branch_needs_pull_req \
		"${DEV_BRANCH_PREFIX}master" || continue
	    barclamps_to_push+=("$bc/${DEV_BRANCH_PREFIX}master")
	    branches_to_push["$branch"]="true"
	done
	[[ ${branches_to_push["$branch"]} ]] && continue
	in_repo branch_needs_pull_req "$branch" || continue
	branches_to_push["$branch"]="true"
    done
    [[ ${!branches_to_push[*]} || ${barclamps_to_push} ]] || {
	echo "Everything up to date, no pull requests are possible."
	return 0
    }
    echo "Barclamps to update: ${barclamps_to_push[*]-(none)}"
    echo -n "Branches to update: "
    [[ ${!branches_to_push[*]} ]] && echo "${!branches_to_push[*]}" || \
	echo "(none)"
    echo "Command to generate pull requests:"
    echo -n "  $0 pull-requests-gen"
    [[ ${!branches_to_push[*]} ]] && \
	echo -n " --branches ${!branches_to_push[*]}"
    [[ ${barclamps_to_push[*]} ]] && \
	echo -n " --barclamps ${barclamps_to_push[*]}"
    echo
}

# Actaully generate a pull request by using make_pull_request to 
# create the JSON blob that github needs, and then posting that to the 
# right URL at Github.
do_pull_request() {
    # $1 = url to POST to
    # rest of args passed verbatim to make_pull_request helper.
    local posturl="$1"
    shift
    make_pull_request "$@" | \
    	curl -X POST --data @- -u "$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD" \
    	-H "Content-Type: application/vnd.github.beta.raw+json" \
    	"$posturl"
}

# Get the diffstat from the origin branch of the branch passed,
# or print an error message if there is no origin.
diffstat_from_origin() {
    if git rev-parse --verify -q "origin/$1" &>/dev/null; then 
        git diff --stat "origin/$1" "$1" 
    else 
        echo "No origin to generate diffstat"
    fi
}

# Make pull requests based on the command line args passed.
# These should follow the command line arguments that 
# pull_requests_prep generated.
pull_requests_gen() {
    # $@ = options to parse
    local -A barclamps branches barclamp_branches bc_pulls br_pulls refs
    local bc br bcr title body option bc_name head
    local prc=0 n=1
    echo "Enter a title for this pull request series."
    echo "After you have entered a title, an editor will open, and you can"
    echo "enter anything you want for the body of the pull requests."
    read -p "Title: " title
    body="$(mktemp /tmp/crowbar-pull-req-XXXXXXXX)"
    if [[ $EDITOR ]]; then
	$EDITOR "$body"
    else
	nano "$body"
    fi
    # Parse our options and validate them.
    while [[ "$1" ]]; do
	case $1 in
	    --branches) 
		shift
		while [[ $1 && $1 != '--'* ]]; do
		    br="$1"
		    shift
		    in_repo branch_exists "$br" || \
			die "$br is not a branch in Crowbar!"
		    branches["$br"]="true"
		done;;
	    --barclamps)
		shift
		while [[ $1 && $1 != '--'* ]]; do
		    bc="${1%%/*}"
		    br="${1#*/}"
		    [[ $bc = $br ]] && br="${DEV_BRANCH_PREFIX}master"
		    shift
		    is_barclamp "$bc" || die "$bc is not a barclamp!"
		    in_barclamp "$bc" branch_exists "$br" || \
			die "$br is not a branch in barclamp $bc!"
		    [[ $br = *master ]] || \
			die "Non-master branch for a barclamp passed.  Not valid for now."
		    barclamps["$bc"]="true"
		    is_in "$br" "${barclamp_branches["$bc"]}" || \
			barclamp_branches["$bc"]+=" $br"
		done;;
	    *) die "Unknown option $1 to $0 pull-requests-gen!";;
	esac
    done
    # The logic here is:
    # Find the "most central" branch for the current set of pull reqs.
    # Record that we need pull requests for each item we find.
    # lather, rinse, repeat until we are out of branches.

    for br in $(filter_branches_for_remote origin $(ordered_branches)); do
	for bc in $(barclamps_from_branch "$br"); do
	    [[ ${barclamps[$bc]} ]] || continue
	    for bcb in ${barclamp_branches["$bc"]}; do
		bc_pulls["$bc/$bcb"]="true"
	    done
	    [[ ${refs["$br"]} ]] || \
		refs["$br"]="$(in_repo git rev-parse --verify -q "refs/heads/$br")"
	    if ! [[ $(in_repo git symbolic-ref HEAD) = "refs/heads/$br" ]]
	    then
		[[ $head ]] || head="$(in_repo git symbolic-ref HEAD)" || \
		    die "pull-requests-gen: Crowbar not on a branch!"
		in_repo git checkout "$br" || \
		    die "pull-requests-gen: Could not checkout $br"
	    fi
	    in_repo git add "barclamps/$bc"
	done
	if [[ ${refs["$br"]} ]]; then
	    in_repo git commit -m "Add updated submodule references for $br"
	    local parent="$(parent_branch "$br")"
	    [[ $parent ]] && in_repo git merge -q "$parent"
	    local refname="$(in_repo git describe --all --long --match "$br")"
	    refname=${refname//\//-}
	    # ... and push it to our personal github repo.
	    in_repo git push -f personal HEAD:"pull-req-$refname"
	    br_pulls["$br"]="true"
	fi
	[[ ${branches["$br"]} ]] && br_pulls["$br"]=true
    done
    # OK, now we know how many pull requests we have to issue.
    prc=$((${#bc_pulls[@]} + ${#br_pulls[@]}))

    # issue the pull requests for our barclamps.
    for barclamp in "${!bc_pulls[@]}"; do
	local bc=${barclamp%%/*}
	local bcb=${barclamp#*/}
	local bc_name=$(in_barclamp $bc git config --get remote.origin.url)
        bc_name=${bc_name##*/}
        bc_name=${bc_name##*:}
        bc_name=${bc_name%.git}
	do_pull_request "https://api.github.com/repos/dellcloudedge/$bc_name/pulls" \
	    --title "$title [$n/$prc]" --base "$bcb" \
	    --head "$DEV_GITHUB_ID:$(in_barclamp "$bc" git rev-parse "$bcb")" \
	    --body "@$body" \
	    --body "$(in_barclamp "$bc" diffstat_from_origin "$bcb")" 
	n=$(($n + 1))
    done

    # Now, issue the requests for branches. 
    # Make sure they are ordered correctly.
    for br in $(filter_branches_for_remote origin $(ordered_branches)); do
	[[ ${br_pulls["$br"]} ]] || continue
	do_pull_request "https://api.github.com/repos/dellcloudedge/crowbar/pulls" \
	    --title "$title [$n/$prc]" --base "$br" \
	    --head "$DEV_GITHUB_ID:$(in_repo git rev-parse "$br")" \
	    --body "@$body" \
	    --body "$(in_repo diffstat_from_origin "$br")"
	n=$(($n + 1))
	if [[ ${refs["$br"]} ]]; then
	    in_repo git checkout "$br"
	    in_repo git reset --hard "${refs[$br]}"
	fi
    done
    [[ $head ]] && in_repo git checkout "${head#refs/heads/}"
    rm -f "$body"
}

# Unconditionally push either the current branch or the branches
# passed on the command line to the personal remote.
push_branches() {
    # $@ = Local branches to push
    local branches=("$@") br btp=()
    [[ $branches ]] || br=($(in_repo git symbolic-ref HEAD)) || \
	die "Main Crowbar repo is not on a branch we can push!"
    [[ $br ]] && branches=("${br#refs/heads/}")
    for br in "${branches[@]}"; do
	if in_repo git rev-parse --verify -q "$br" &>/dev/null; then
	    btp+=("$br")
	else
	    echo "$br is not a branch I can push!"
	fi
    done
    echo "Pushing ${btp[*]} to your Github fork of Crowbar."
    in_repo git push personal "${btp[@]}"
}

# Show the releases that either the local repo or the origin repo knows about.
show_releases() {
    local sum ref r
    local br_re='^(refs/(heads|remotes/([^/]+))/)'
    local -A releases
    while read sum ref; do
	[[ $ref =~ $br_re ]] || continue
	ref=${ref#${BASH_REMATCH[1]}}
	# Filter out "extra" remotes.
	if [[ ${BASH_REMATCH[3]} ]]; then
	    is_in "${BASH_REMATCH[3]}" "${!DEV_REMOTE_BRANCHES[*]}" || \
		continue
	fi
	case ${ref} in
	    master) r=development;;
	    stable/master) r=stable;;
	    release/*)
		r="${ref#release/}"
		r=${r%%/*};;
	esac
	[[ ${releases["$r"]} ]] || releases["$r"]="$r"
    done < <(in_repo git show-ref master)
    echo "${releases[*]}"
    
}

# Given a release name, give us the proper brach prefix for it.
release_branch_prefix() {
    # $1 = release name
    case $1 in
	development) : ;;
	stable) echo "stable/";;
	*) echo "release/$1/";;
    esac
}

DEV_BRANCH_PREFIX="$(release_branch_prefix $(current_release))"

# Create a new release branch structure based on the current state of the
# Crowbar repositories.
cut_release() {
    local b this_prefix new_prefix
    
    [[ $1 ]] || die "cut_release: Please specify a name for the new release"

    # Test to see if release exists.
    is_in "$1" "$(show_releases)" && die "cut_release: Name already exists"

    crowbar_is_clean &>/dev/null || \
  	die "Crowbar repo must be clean before trying to cut a release!"
    this_prefix=$DEV_BRANCH_PREFIX
    new_prefix="$(release_branch_prefix $1)"
    # Make release copy of all branches.

    for b in "${!DEV_BRANCHES[@]}"; do
	in_repo git branch "${new_prefix}${b}" "${this_prefix}${b}"
    done

    local barclamps="$(barclamps_in_branch "${!DEV_BRANCHES[@]}")" || \
	die "Could not get list of barclamps for our dev branches!"
    for b in $barclamps; do
	in_barclamp "$b" git branch ${new_prefix}master ${this_prefix}master
    done
}

# Check out all the branches in the main Crowbar repository and the barclamps
# for a given release.
switch_release() {
    local b new_base

    [[ $1 ]] || die "switch: Please specify a release name to switch to"
    is_in "$1" "$(show_releases)" || die "switch: $1 does not exist"
    crowbar_is_clean &>/dev/null || \
  	die "Crowbar repo must be clean before trying to switch releases!"
    
    new_base="$(release_branch_prefix "$1")"
    
    b=$(in_repo git symbolic-ref HEAD) || die "switch: Crowbar not on a branch."
    b=${b##*/}
    in_repo branch_exists "${new_base}${b}" || {
            echo "$1 does not have branch $b, will checkout master instead."
	b=master
    }

    in_repo git checkout "${new_base}${b}"
    local barclamps="$(barclamps_in_branch "${!DEV_BRANCHES[@]}")" || \
	exit 1
    for b in $barclamps; do
	in_barclamp "$b" git checkout "${new_base}master"
    done
}

case $1 in
    is_clean) crowbar_is_clean;;
    fetch) fetch_all;;
    sync) sync_everything;;
    setup) setup;;
    backup) backup_everything;;
    push) shift; push_branches "$@";;
    pull-requests-prep) pull_requests_prep;;
    pull-requests-gen) shift; pull_requests_gen "$@";;
    help) dev_help;;
    release) current_release;;
    releases) show_releases;;
    cut_release) shift; cut_release "$@";;
    switch) shift; switch_release "$@";;
    *) dev_help ; die "Unknown command $1.  Please use \"help\" for help.";;
esac
