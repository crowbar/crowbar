#!/bin/bash

export LANG="C"
export LC_ALL="C"

GEM_RE='([^0-9].*)-([0-9].*)'

readonly currdir="$PWD"
export PATH="$PATH:/sbin:/usr/sbin:/usr/local/sbin"
declare -A DEV_BRANCHES DEV_REMOTES DEV_REMOTE_BRANCHES DEV_ORIGIN_TYPES
DEV_BRANCHES["master"]="master"
DEV_BRANCHES["openstack-os-build"]="master"
DEV_BRANCHES["hadoop-os-build"]="master"
DEV_BRANCHES["openstack-build"]="openstack-os-build"
DEV_BRANCHES["hadoop-build"]="hadoop-os-build"
DEV_REMOTES["origin"]="https://github.com/dellcloudedge/"
DEV_REMOTES["dell"]="gitolite@10.9.244.31:"
DEV_ORIGIN_TYPES["origin"]="github"
DEV_ORIGIN_TYPES["dell"]="gitolite"
DEV_REMOTE_BRANCHES["origin"]="master openstack-os-build hadoop-os-build"
DEV_REMOTE_BRANCHES["dell"]="openstack-build hadoop-build"

# Source our config file if we have one
[[ -f $HOME/.build-crowbar.conf ]] && \
    . "$HOME/.build-crowbar.conf"

# Look for a local one.
[[ -f build-crowbar.conf ]] && \
    . "build-crowbar.conf"

# Set up our proxies if we were asked to.
if [[ $USE_PROXY = "1" && $PROXY_HOST ]]; then
    proxy_str="http://"
    if [[ $PROXY_PASSWORD && $PROXY_USER ]]; then
	proxy_str+="$PROXY_USER:$PROXY_PASSWORD@"
    elif [[ $PROXY_USER ]]; then
	proxy_str+="$PROXY_USER@"
    fi
    proxy_str+="$PROXY_HOST"
    [[ $PROXY_PORT ]] && proxy_str+=":$PROXY_PORT"
    [[ $no_proxy ]] || no_proxy="localhost,localhost.localdomain,127.0.0.0/8,$PROXY_HOST" 
    [[ $http_proxy ]] || http_proxy="$proxy_str/" 
    [[ $https_proxy ]] || https_proxy="$http_proxy"
    export no_proxy http_proxy https_proxy
else
    unset no_proxy http_proxy https_proxy
fi

# Location of the Crowbar checkout we are building from.
[[ $CROWBAR_DIR ]] || CROWBAR_DIR="${0%/*}"
[[ $CROWBAR_DIR = /* ]] || CROWBAR_DIR="$currdir/$CROWBAR_DIR"
[[ -f $CROWBAR_DIR/build_crowbar.sh && -d $CROWBAR_DIR/.git ]] || \
    die "$CROWBAR_DIR is not a git checkout of Crowbar!" 
export CROWBAR_DIR

. "$CROWBAR_DIR/build_lib.sh" || exit 1
trap - 0 INT QUIT TERM

which gem &>/dev/null || \
    die "Rubygems not installed, and some of our helpers need a JSON gem."

gem list -i json &>/dev/null || \
    die "JSON gem not installed.  Please install it with gem install json."

set -o pipefail

# If we have openstack-os-build and hadoop-os-build brancehs locally,
# let the merge engine know about them.

for branch in openstack-os-build hadoop-os-build; do
    [[ ${DEV_BRANCHES[$branch]} ]] && continue
    in_repo branch_exists "$branch" || continue
done

# Sanity-check our dependency hash

for branch in "${!DEV_BRANCHES[@]}"; do
    in_repo branch_exists "$branch" || \
	die "$branch is specified in \$DEV_BRANCHES, but does not exist!"
    in_repo branch_exists "${DEV_BRANCHES[$branch]}" || \
	die "${DEV_BRANCHES[$branch]} dies not exist, but it is specified as the parent of $branch!"
done

child_branches() {
    local p=${1#$DEV_BRANCH_PREFIX} b
    for b in "${!DEV_BRANCHES[@]}"; do 
	[[ ${DEV_BRANCHES[$b]} && \
	    ${DEV_BRANCHES[$b]} != $b && \
	    ${DEV_BRANCHES[$b]} = $p ]] || continue
	echo "$DEV_BRANCH_PREFIX$b"
    done
    return 0
}
	
parent_branch() {
    local p="${DEV_BRANCHES[${1##*/}]}"
    [[ $p && $p != ${1##*/} ]] && echo "${DEV_BRANCH_PREFIX}${p}"
    return 0
}

root_branches() {
    local b
    for b in "${!DEV_BRANCHES[@]}"; do
	[[ $b = ${DEV_BRANCHES[$b]} ]] || continue
	echo "${DEV_BRANCH_PREFIX}$b"
    done
    return 0
}


git_is_clean() {
    local line hpath ret=0
    while read line; do
	case $line in
	    # Untracked file.  Ignore it if it is also a git repo, 
	    # complain otherwise.
	    '??'*) hpath=${line%% ->*}
                   hpath=${hpath#* }
		   [[ -d $hpath && -d $hpath.git ]] && continue
                   ret=1;;
	    '') continue;;
	    *) ret=1;
	esac
    done < <(git status --porcelain --ignore-submodules)
    [[ $ret = 0 ]] && return
    git status
    [[ $IGNORE_CLEAN ]] && return 0
    return 1
}

current_release() {
    local ans="$(in_repo git symbolic-ref HEAD)" || \
	die "current_release: Cannot get current branch information!"
    ans=${ans#refs/heads/}
    case $ans in
	personal/*) continue;;
	stable/*) echo "stable";;
	release/*)
	    ans="${ans#release/}"
	    echo "${ans%%/*}";;
	*) echo "development";;
    esac
}

barclamp_is_clean() { in_barclamp "$1" git_is_clean; }

barclamps_are_clean() {
    local bc
    for bc in "$CROWBAR_DIR/barclamps/"*; do
	is_barclamp "${bc##*/}" || continue
	(cd "$bc"; git_is_clean) || return 1
    done
}

crowbar_is_clean() { barclamps_are_clean && in_repo git_is_clean; }

barclamps_in_branch() {
    local b res=()
    for b in "$@"; do
	in_repo branch_exists "$b" || \
	    die "Branch $b does not exist in the Crowbar repo!"
    done
    local res=($(for b in "$@"; do in_repo git ls-tree -r \
	"$b" barclamps; done | \
	awk '/160000 commit/ {print $4}' |sort -u))
    echo "${res[@]#barclamps/}"
}

fetch_all() {
    local remote barclamps b
    for remote in "${!DEV_REMOTES[@]}"; do
        [[ $VERBOSE ]] && echo "Fetching $remote"
	in_repo git fetch "$remote" || continue
    done
    local barclamps="$(barclamps_in_branch "${!DEV_BRANCHES[@]}")" || \
	exit 1
    for b in $barclamps; do
        [[ $VERBOSE ]] && echo "Fetching $b"
	in_barclamp "$b" git fetch || \
	    die "Cound not fetch updates for $b"
    done
}

curl_and_res() {
    curl "$@"
    case $? in
	0) return 0;;
	7) echo "Unable to contact Github, please try again later." >&2
	    return 1;;
	22) return 1;;
	*) echo "Curl reported error ${?}!." >&2
	    return 1;;
    esac
}

[[ ( $DEV_GITHUB_ID && $DEV_GITHUB_PASSWD) || $1 = setup ]] || \
    die "dev has not been configured. Please run $CROWBAR_DIR/dev setup first."

github_fork() {
    # $1 = user to fork from
    # $2 = repo to fork
    curl_and_res -f -u "$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD" -X POST \
	"https://api.github.com/repos/$1/$2/forks" >&/dev/null || \
	die "Could not fork $1/$2!"
}

setup() {
    local p
    crowbar_is_clean &>/dev/null || \
    	die "Crowbar repo must be clean before trying to set things up!"
    [[ $DEV_GITHUB_ID && $DEV_GITHUB_PASSWD ]] || {
	read -p "Enter your Github username: " DEV_GITHUB_ID
	curl_and_res -f \
	    "https://api.github.com/users/$DEV_GITHUB_ID" &>/dev/null || \
	    die "Could not verify that $DEV_GITHUB_ID is a valid Github user.."
	while [[ $p != $DEV_GITHUB_PASSWD || ! $p ]]; do
	    [[ $p ]] && echo "Passwords did not match, try again."
	    read -s -p "Enter your Github password: " DEV_GITHUB_PASSWD
	    echo
	    read -s -p "Enter your Github password again: " p
	    echo
	done
	curl_and_res -f -u "$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD" \
	    https://api.github.com/user &>/dev/null || {
	    echo "Unable to authenticate with Github as user $DEV_GITHUB_ID." >&2
	    die "Please try again when you have Github access."
	}
	echo "DEV_GITHUB_ID=\"$DEV_GITHUB_ID\"" >> "$HOME/.build-crowbar.conf"
	echo "DEV_GITHUB_PASSWD=\"$DEV_GITHUB_PASSWD\"" >> "$HOME/.build-crowbar.conf"
    }

    echo "Finding Github repos..."
    local repos=($(
	    eval "$(curl -f -u "$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD" \
		https://api.github.com/user/repos 2>/dev/null | \
		parse_yml_or_json - name)" 
	    echo "${name[@]}"))
    if ! is_in crowbar "${repos[*]}"; then
	echo "Creating your fork of Crowbar on Github."
	github_fork dellcloudedge crowbar || die "Unable to create your fork of Crowbar."
    fi
    if ! in_repo git config --get remote.personal.url &>/dev/null; then
	echo "Adding remote for personal fork of crowbar on Github."
	in_repo git remote add personal \
	    "https://$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD@github.com/$DEV_GITHUB_ID/crowbar.git"
	in_repo git fetch personal || \
	    die "Cannot fetch repository info for your Crowbar fork on Github!"
	in_repo git remote set-head -a personal
    fi
    
    for b in ${DEV_REMOTE_BRANCHES["origin"]}; do
	in_repo git checkout "$b" || \
	    die "Cannot checkout $b"
	in_repo git merge "origin/$b" || \
	    die "Cannot merge origin/$b into $b"
	in_repo git submodule update --init || \
	    die "Cannot check out submodules for branch $b"
	in_repo git submodule sync || \
	    die "Cannot sync origin URLs for branch $b"
    done
    in_repo git checkout master
    for b in $(barclamps_in_branch ${DEV_REMOTE_BRANCHES["origin"]}); do
	(   cd "$CROWBAR_DIR/barclamps/$b"
	    repo="$(git config --get remote.origin.url)"
	    [[ $repo =~ /dellcloudedge/ ]] || continue
	    repo="${repo##*/}"
	    repo="${repo%.git}"
	    is_in "$repo" "${repos[*]}" || \
		github_fork dellcloudedge "$repo" || \
		die "Could not create a personal fork of $repo"
	    if ! git config --get remote.personal.url &>/dev/null; then
		git remote add personal \
		    "https://$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD@github.com/$DEV_GITHUB_ID/$repo.git"
		in_repo git fetch personal || \
		    die "Cannot fetch repositroy info for your fork of $repo on Github."
		in_repo git remote set-head -a personal
	    fi
	) || exit 1
    done
}

remote_branches_synced() {
    # $1 = repository to operate in
    # $2 = local branch to test
    # $3 = remote branch to test
    [[ -d $1/.git ]] || \
	die "remote_branches_synced: $1 is not a git repo"
    [[ $VERBOSE2 ]] && echo "Checking to see if out of sync: $2 $3"
    (cd "$1"; git rev-parse --verify -q "$2" &>/dev/null) || \
	return 1
    (cd "$1"; git rev-parse --verify -q "$3" &>/dev/null) || \
	return 1
    # $2 and $3 resolve to the same commit, they are in sync.
    (cd "$1"; [[ $(git rev-parse "$2") = $(git rev-parse "$3") ]] ) && return 0
    # Test to see if there are any commits in $3 that are not
    # reachable from $2.  If there are, then the branches are not synced.
    (cd "$1"; [[ ! $(git rev-list "$2..$3") ]] ) && return 0
    return 1
}

github_backup() (
    local repo=$1 branches=() ref branch
    cd "$repo"
    while read ref branch; do
	branch="${branch#refs/heads/}"
		# If we have a ref for this branch on the personal remote
		# and the local branch does not contain any commits that 
		# the one on the personal remote does, then it is already
		# synced and we can skip the actual network communication.
	git rev-parse --verify -q \
	    refs/remotes/personal/$branch &>/dev/null && \
	    remote_branches_synced "." \
	    refs/remotes/personal/$branch refs/heads/$branch && \
	    continue
	branches+=("$branch")
    done < <(git show-ref --heads)
    if [[ $branches ]]; then
	echo "Pushing ${branches[*]} to personal barclamp ${repo##*/}" >&2
	git push -qf personal "${branches[@]}" || \
	    die "Could not push ${branches[*]} to personal barclamp ${repo##*/}"
    fi
)

generic_backup() (
    local repo="$1" branches=() branch ref 
    shift
    local prefix="refs/heads/personal/$DEV_GITHUB_ID"
    cd "$repo"
    if [[ $(git symbolic-ref HEAD) = "$prefix"/* ]]; then
	die "generic_backup: Personal branch currently checked out, cannot proceed."
    fi
    while read ref branch; do
	if [[ $branch = "$prefix"/* ]]; then
	    b=${branch#$prefix/}
	    branch_exists "$b" || git branch -D "$branch#refs/heads/"
	    continue
	fi
	branch=${branch#refs/heads/}
        branch_exists "personal/$DEV_GITHUB_ID/$branch" && \
	    [[ $(git rev-parse --verify -q "refs/remotes/origin/personal/$DEV_GITHUB_ID/$branch") && \
	    $(git rev-parse "refs/remotes/origin/personal/$DEV_GITHUB_ID/$branch") = \
	    $(git rev-parse "refs/heads/$branch") ]] && continue
	git branch -f "personal/$DEV_GITHUB_ID/$branch" "$branch"
	branches+=("personal/$DEV_GITHUB_ID/$branch")
    done < <(git show-ref --heads)
    if [[ $branches ]]; then
	echo "Pushing personal refs for ${branches[*]} to origin of barclamp ${repo##*/}"
	git push -qf origin "${branches[@]}"
    fi
)

backup_everything() {
    local bc branch branches=() remote backup_func
    for bc in "$CROWBAR_DIR/barclamps/"*; do
	[[ -d $bc && -d $bc/.git ]] || continue
	if in_barclamp "${bc##*/}" \
	    git config --get remote.personal.url &>/dev/null; then
	    github_backup "$bc" || die "Could not back up barclamp ${bc##*/}"
	else
	    generic_backup "$bc" || die "Could not back up barclamp ${bc##*/}"
	fi
    done
    if in_repo git config --get remote.personal.url &>/dev/null; then
	# Push branches that have been pushed to personal in the past
	while read ref branch; do
	    branch="${branch#refs/heads/}"
	    # If we do not have a ref for this branch on the personal remote
	    # or on the origin remote, this branch should not be backed up.
	    ( git rev-parse --verify -q \
		refs/remotes/personal/$branch &>/dev/null || \
		git rev-parse --verify -q \
		refs/remotes/origin/$branch &>/dev/null) || continue
	    # If this branch has a personal remote and the local branch 
            # does not contain any commits that the one on the personal 
	    # remote does, then it is already synced and we can skip 
	    # the actual network communication.
	    git rev-parse --verify -q \
		refs/remotes/personal/$branch &>/dev/null && \
		remote_branches_synced "." \
		refs/remotes/personal/$branch refs/heads/$branch && \
		continue
	    branches+=("$branch")
	done < <(git show-ref --heads)
	if [[ $branches ]]; then
	    echo "Pushing ${branches[*]} to personal Crowbar"
	    in_repo git push -qf personal "${branches[@]}" || \
		die "Could not push ${branches[*]} to personal Crowbar!"
	fi
	
    fi
}

sync_repo() (
    local branch head b bc origin ref
    # $1 = dir to CD to initially.
    # Assumes that origin has already been fetched.
    cd "$1"
    # Repo is not clean, we will refuse to merge in any case.
    git_is_clean || {
	echo "$1 is not clean." >&2
	return 1
    }
    # Merge upstream branches from all origins, but only if the branch
    # is listed in DEV_REMOTE_BRANCHES for that origin, 
    # unless $origin is actually "origin"
    while read ref branch; do
	branch=${branch#refs/heads/}
	for origin in "${!DEV_REMOTE_BRANCHES[@]}"; do
            remote=$(git config branch.${branch}.remote)
	    [[ $origin = origin ]] || \
                [[ $remote ]] || \
		is_in "${branch##*/}" "${DEV_REMOTE_BRANCHES[$origin]}" || \
		continue
	    git rev-parse --verify -q "$origin/$branch" &>/dev/null || continue
	    remote_branches_synced "$1" "refs/heads/$branch" "refs/remotes/$origin/$branch" && continue
	    [[ $head ]] || head=$(git symbolic-ref HEAD) || {
	    # Oh, boy, we are in detached HEAD.
	    # Die with a possibly-helpful error message.
		echo "$1 has had commits to a detached HEAD." >&2
		echo "git submodule update probably left it in this state." >&2
		echo "It should probably be on ${DEV_BRANCH_PREFIX}master, but you need to fix it."
		return 1 
	    }
            [[ $VERBOSE ]] && echo "Checking out $branch"
	    git checkout "$branch" || {
		echo "$bc: Unable to checkout $branch!" >&2
		return 1
	    }
            [[ $VERBOSE ]] && echo "Merging $origin/$branch into $branch"
	    git merge "$origin/$branch" || {
		echo "$1: Unable to merge $origin/$branch into $branch, will unwind." >&2
		git reset --hard
		return 1
	    }
	done 
    done < <(git show-ref --heads)
    if [[ $head ]]; then git checkout "${head#refs/heads/}"; fi
)

ripple_changes_out() {
    # $1 branch to ripple changes from. Changes will be rippled to all 
    # children of $1.
    local parent="$1" child
    in_repo git rev-parse --verify -q "$parent" &>/dev/null || \
	die "ripple_changes_out: $parent is not a branch in Crowbar!"
    for child in $(child_branches "$parent"); do
	in_repo git rev-parse --verify -q "$parent" &>/dev/null || \
	    die "ripple_changes_out: $child is not a branch in Crowbar!"
        [[ $VERBOSE ]] && echo "Testing $parent -> $child"
	remote_branches_synced "$CROWBAR_DIR" "refs/heads/$child" "refs/heads/$parent" && continue
	[[ $head ]] || head=$(in_repo git symbolic-ref HEAD) || \
	    die "Could not save the current branch!"
        [[ $VERBOSE ]] && echo "Checking out $child"
	[[ $(in_repo git symbolic-ref HEAD) = refs/heads/$child ]] || \
	    in_repo git checkout "$child"
        [[ $VERBOSE ]] && echo "Merging $parent into $child"
	in_repo git merge "$parent" || \
	    die "Merge $parent into $child branch of Crowbar failed."
	ripple_changes_out "$child"
    done
}

sync_everything() {
    local unsynced_barclamps=()
    local b u head res=0 ref branch rel
    crowbar_is_clean || \
	die "Will not try to sync local repo with origin when working tree is dirty."
    # Do barclamps first.
    for b in $(barclamps_in_branch ${DEV_REMOTE_BRANCHES[@]}); do
        [[ $VERBOSE ]] && echo "Syncing $b"
	sync_repo "$CROWBAR_DIR/barclamps/$b" && continue
	unsynced_barclamps+=("$b")
    done
    # Finished with barclamps, now for crowbar.
    [[ $VERBOSE ]] && echo "Syncing crowbar"
    sync_repo "$CROWBAR_DIR" || \
	die "Could not sync Crowbar with origin branches"
    # Now for the branch-rippling merges of doom
    for branch in $(root_branches); do
	ripple_changes_out "$branch"
    done
    [[ $head ]] && in_repo git checkout "${head#refs/heads/}"
    if [[ $unsynced_barclamps ]]; then
	echo "Unable to sync origin with current master in:" >&2
	echo "  ${unsynced_barclamps[*]}"
	res=1
    fi
    [[ $res = 0 ]] && return 0
    echo 
    echo "Please fix things up and rerun sync."
    return 1
}

dev_help () {
    cat <<EOF
$0: Development helper for Crowbar.

Command line options:

  setup -- Sets up your local Crowbar repositories for working with the 
           new Github regime.  This command will prompt for your Github
           login information, make sure you have local copies of all the
           barclamp repos that Crowbar references checked out, create personal
           forks of all the crowbar repos from the dellcloudedge account on
           github, and create the appropriate remotes needed for day-to-day
           operation.

  is_clean -- Check to see if the barclamps have everything committed
              with no untracked files, and check to see if the main
              Crowbar repository is clean while ignoring submodule references.

  fetch -- Fetch all changes from the dellcloudedge Crowbar repositories.
           Does not try to merge any changes into your local repository.
           You can run a fetch at any time without disturbing your working
           code, provided you have network connectivity.

  backup -- Push any locally committed changes in any repositories that were
            initially forked from dellcloudedge into your personal Github forks.
            You can run a backup at any time without disturbing your working
            code, provided you have network connectivity.

  sync -- Merge any changes that have been fetched into the current
          repositories.  dev is_clean should exit without any messages before
          running this command.

  push -- Unconditionally push a branch (or branches) to your crowbar Github
          fork.  Any arguments are interpreted as branch names to push, and
          if there are no arguments it pushes the branch you are currently on.
          Any branches pushed using this command will automatically be backed
          up when dev backup is run as well.

  pull-requests-prep -- Fetches, Syncs, and backs up all changes.  Then figures out
                        The set of barclamps and crowbar branches that need to have
                        pull requests created.  The output is a command line that can
                        be copied and executed.

  pull-requests-gen -- Creates a set of pull requests with similar ids and links based
                       upon the barclamps dependency trees.  These will be automatically
                       sent to Github for processing and review by others on the team.

  release -- Shows the current release that dev is operating on.

  releases -- Lists the releases to choose from.

  switch -- Change current release to the specified release.

  cut_release -- DO NOT USE UNLESS YOU KNOW WHAT YOU ARE DOING! Makes a new set
                 of branches and barclamp branches from the current release into
                 the new named release.  Must provide a unique new name.

EOF
}

classify_barclamps() {
    # No args, but it assumes that barclamps is an associative array
    # of the form:
    # barclamps["barclamp"]="somehting"
    # classify_barclamps will mutate the array so that "something" refers
    # to the branch that the barclamp is hosted in.  The value will be left
    # unchanged if we cannot figure out where that barclamp is hosted.
    local branch bc
    for branch in ${DEV_REMOTE_BRANCHES["origin"]}; do
	for bc in $(barclamps_in_branch "$branch"); do
	    # If we don't care about this barclamp, skip it.
	    [[ ${barclamps["$bc"]} ]] || continue
	    # If we have already looked at this barclamp, skip it.
	    is_in "${barclamps["$bc"]}" "${DEV_REMOTE_BRANCHES["origin"]}" && \
		continue
	    barclamps["$bc"]="$branch"
	done
    done
}

pull_requests_prep() {
    crowbar_is_clean && fetch_all && sync_everything && backup_everything || \
    	die "Unable to prepare for pull requests"
    local -A barclamps
    local branches_to_push=() barclamps_to_push=()
    local branch bc
    for bc in "$CROWBAR_DIR/barclamps/"*; do
	is_barclamp "${bc##*/}" && barclamps["${bc##*/}"]="unclassified"
    done
    classify_barclamps
    for bc in "${!barclamps[@]}"; do
	# If this barclamp did not get classified, skip it.
	[[ ${barclamps["$bc"]} = unclassified ]] && continue
	# If there are no commits in master that are not already in 
	# origin/${DEV_BRANCH_PREFIX}master, skip it.    
	in_barclamp "$bc" git rev-parse --verify -q \
	    "origin/${DEV_BRANCH_PREFIX}master" &>/dev/null && \
	    in_barclamp "$bc" \
	    remote_branches_synced '.' \
	    "refs/remotes/origin/${DEV_BRANCH_PREFIX}master" \
	    "refs/heads/${DEV_BRANCH_PREFIX}master" && \
	    continue
	barclamps_to_push+=("$bc/${DEV_BRANCH_PREFIX}master")
	is_in "${DEV_BRANCH_PREFIX}${barclamps["$bc"]}" \
	    "${branches_to_push[*]}" || \
	    branches_to_push+=("${DEV_BRANCH_PREFIX}${barclamps["$bc"]}")
    done
    for branch in ${DEV_REMOTE_BRANCHES["origin"]}; do
	in_repo git rev-parse --verify -q \
	    "origin/${DEV_BRANCH_PREFIX}$branch" &>/dev/null && \
    	    remote_branches_synced "$CROWBAR_DIR" \
	    "refs/remotes/origin/${DEV_BRANCH_PREFIX}$branch" \
	    "refs/heads/${DEV_BRANCH_PREFIX}$branch" || \
	    is_in "${DEV_BRANCH_PREFIX}$branch" "${branches_to_push[*]}" || \
	    branches_to_push+=("${DEV_BRANCH_PREFIX}$branch")
    done
    [[ ${branches_to_push} || ${barclamps_to_push} ]] || {
	echo "Everything up to date, no pull requests are possible."
	return 0
    }
    echo "Barclamps to update: ${barclamps_to_push[*]-(none)}"
    echo "Branches to update: ${branches_to_push[*]-(none)}"
    echo "Command to generate pull requests:"
    echo -n "  $0 pull-requests-gen"
    [[ ${branches_to_push[*]} ]] && \
	echo -n " --branches ${branches_to_push[*]}"
    [[ ${barclamps_to_push[*]} ]] && \
	echo -n " --barclamps ${barclamps_to_push[*]}"
    echo
}

do_pull_request() {
    # $1 = url to POST to
    # rest of args passed verbatim to make_pull_request helper.
    local posturl="$1"
    shift
    make_pull_request "$@" | \
    	curl -X POST --data @- -u "$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD" \
	-H "Content-Type: application/vnd.github.beta.raw+json" \
    	"$posturl"
}

pull_requests_gen() {
    # $@ = options to parse
    local -A barclamps pull_requests barclamp_branches branches
    local bc br bcr title body option handled_branches=() bc_name
    local pull_request_count=0 n=1
    while [[ "$1" ]]; do
	case $1 in
	    --branches) 
		shift
		while [[ $1 && $1 != '--'* ]]; do
		    br="$1"
		    shift
		    in_repo branch_exists "$br" || \
			die "$br is not a branch in Crowbar!"
		    [[ ${branches["$br"]} ]] || {
			branches["$br"]="${DEV_BRANCHES["${br##*/}"]}"
			pull_request_count=$((pull_request_count + 1))
		    }
		done;;
	    --barclamps)
		shift
		while [[ $1 && $1 != '--'* ]]; do
		    bc="${1%%/*}"
		    br="${1#*/}"
		    [[ $bc = $br ]] && br="${DEV_BRANCH_PREFIX}master"
		    shift
		    is_barclamp "$bc" || die "$bc is not a barclamp!"
		    in_barclamp "$bc" branch_exists "$br" || \
			die "$br is not a branch in barclamp $bc!"
		    [[ $br = *master ]] || \
			die "Non-master branch for a barclamp passed.  Not valid for now."
		    [[ ${barclamps["$bc"]} ]] || barclamps["$bc"]="unclassified"
		    is_in "$br" "${barclamp_branches["$bc"]}" || {
			barclamp_branches["$bc"]+=" $br"
			pull_request_count=$((pull_request_count + 1))
		    }
		done;;
	    *) die "Unknown option $1 to $0 pull-requests-gen!";;
	esac
    done
    classify_barclamps
    for bc in "${!barclamps[@]}"; do
	br=${DEV_BRANCH_PREFIX}${barclamps["$bc"]}
	[[ $br = "${DEV_BRANCH_PREFIX}unclassified" ]] && \
	    die "pull_requests_gen: Encountered unclassified barclamp $bc."
	[[ ${branches["$br"]} ]] || {
	    branches["$br"]="${DEV_BRANCH_PREFIX}${DEV_BRANCHES["${br##*/}"]}"
	    pull_request_count=$((pull_request_count + 1))
	}
    done
    echo "Enter a title for this pull request series."
    echo "After you have entered a title, an editor will open, and you can"
    echo "enter anything you want for the body of the pull requests."
    read -p "Title: " title
    body="$(mktemp /tmp/crowbar-pull-req-XXXXXXXX)"
    if [[ $EDITOR ]]; then
	$EDITOR "$body"
    else
	nano "$body"
    fi
    
    # The logic here is:
    # Find the "most central" branch for the current set of pull reqs.
    # Generate pull requests for branches on its barclamps next.
    # Generate a pull request for that branch next.
    # Find the next most central branch.
    # lather, rinse, repeat until we are out of branches.
    while [[ ${!branches[*]} ]]; do
	for br in "${!branches[@]}"; do
	    # If our parent branch is not ourself, or the hash for our 
	    # parent is not unset, skip past this branch for now.
	    if [[ ${DEV_BRANCH_PREFIX}${branches["$br"]} != \
		$br && ${branches[${DEV_BRANCH_PREFIX}${branches[$br]}]} ]]
	    then
		continue
	    fi	
	    for bc in "${!barclamps[@]}"; do
		[[ ${DEV_BRANCH_PREFIX}${barclamps["$bc"]} = $br ]] || continue
		for bcr in ${barclamp_branches["$bc"]}; do
                    bc_name=$(in_barclamp $bc git config --get remote.origin.url)
                    bc_name=${bc_name##*/}
                    bc_name=${bc_name##*:}
                    bc_name=${bc_name%.git}
		    do_pull_request "https://api.github.com/repos/dellcloudedge/$bc_name/pulls" \
			--title "$title [$n/$pull_request_count]" \
			--base "$bcr" \
			--head "$DEV_GITHUB_ID:$(in_barclamp "$bc" git rev-parse "$bcr")" \
			--body "@$body" \
			--body "$(if in_barclamp "$bc" git rev-parse --verify -q "origin/$bcr" &>/dev/null; then in_barclamp "$bc" git diff --stat "origin/$bcr" $bcr; else echo "No origin to generate diffstat"; fi)" 
		    n=$(($n + 1))
		done
	    done
	    do_pull_request "https://api.github.com/repos/dellcloudedge/crowbar/pulls" \
		--title "$title [$n/$pull_request_count]" \
		--base "$br" \
		--head "$DEV_GITHUB_ID:$(in_repo git rev-parse "$br")" \
		--body "@$body" \
		--body "$(if in_repo git rev-parse -q --verify origin/$br &>/dev/null; then git diff --stat origin/$br $br; else echo "No origin to generate diffstat."; fi)"
	    n=$(($n + 1))
	    # We are done with this branch.  Unset its hash entry.
	    unset branches["$br"]
	    break
	done
    done
    
    rm -f "$body"
    die "pull-requests-gen: Not implimented yet."
}

push_branches() {
    # $@ = Local branches to push
    local branches=("$@") br btp=()
    [[ $branches ]] || br=($(in_repo git symbolic-ref HEAD)) || \
	die "Main Crowbar repo is not on a branch we can push!"
    [[ $br ]] && branches=("${br#refs/heads/}")
    for br in "${branches[@]}"; do
	if in_repo git rev-parse --verify -q "$br" &>/dev/null; then
	    btp+=("$br")
	else
	    echo "$br is not a branch I can push!"
	fi
    done
    echo "Pushing ${btp[*]} to your Github fork of Crowbar."
    in_repo git push personal "${btp[@]}"
}

show_releases() {
    local sum ref r
    local br_re='^(refs/(heads|remotes/([^/]+))/)'
    local -A releases
    while read sum ref; do
	[[ $ref =~ $br_re ]] || continue
	ref=${ref#${BASH_REMATCH[1]}}
	# Filter out "extra" remotes.
	if [[ ${BASH_REMATCH[3]} ]]; then
	    is_in "${BASH_REMATCH[3]}" "${!DEV_REMOTE_BRANCHES[*]}" || \
		continue
	fi
	case ${ref} in
	    master) r=development;;
	    stable/master) r=stable;;
	    release/*)
		r="${ref#release/}"
		r=${r%%/*};;
	esac
	[[ ${releases["$r"]} ]] || releases["$r"]="$r"
    done < <(in_repo git show-ref master)
    echo "${releases[*]}"
    
}

release_branch_prefix() {
    # $1 = release name
    case $1 in
	development) : ;;
	stable) echo "stable/";;
	*) echo "release/$1/";;
    esac
}

DEV_BRANCH_PREFIX="$(release_branch_prefix $(current_release))"

cut_release() {
    local b this_prefix new_prefix
    
    [[ $1 ]] || die "cut_release: Please specify a name for the new release"

    # Test to see if release exists.
    is_in "$1" "$(show_releases)" && die "cut_release: Name already exists"

    crowbar_is_clean &>/dev/null || \
  	die "Crowbar repo must be clean before trying to cut a release!"
    this_prefix=$DEV_BRANCH_PREFIX
    new_prefix="$(release_branch_prefix $1)"
    # Make release copy of all branches.

    for b in "${!DEV_BRANCHES[@]}"; do
	in_repo git branch "${new_prefix}${b}" "${this_prefix}${b}"
    done

    local barclamps="$(barclamps_in_branch "${!DEV_BRANCHES[@]}")" || \
	die "Could not get list of barclamps for our dev branches!"
    for b in $barclamps; do
	in_barclamp "$b" git branch ${new_prefix}master ${this_prefix}master
    done
}

switch_release() {
    local b new_base

    [[ $1 ]] || die "switch: Please specify a release name to switch to"
    is_in "$1" "$(show_releases)" || die "switch: $1 does not exist"
    crowbar_is_clean &>/dev/null || \
  	die "Crowbar repo must be clean before trying to switch releases!"
    
    new_base="$(release_branch_prefix "$1")"
    
    b=$(in_repo git symbolic-ref HEAD) || die "switch: Crowbar not on a branch."
    b=${b##*/}
    in_repo branch_exists "${new_base}${b}" || {
            echo "$1 does not have branch $b, will checkout master instead."
	b=master
    }

    in_repo git checkout "${new_base}${b}"
    local barclamps="$(barclamps_in_branch "${!DEV_BRANCHES[@]}")" || \
	exit 1
    for b in $barclamps; do
	in_barclamp "$b" git checkout "${new_base}master"
    done
}

case $1 in
    is_clean) crowbar_is_clean;;
    fetch) fetch_all;;
    sync) sync_everything;;
    setup) setup;;
    backup) backup_everything;;
    push) shift; push_branches "$@";;
    pull-requests-prep) pull_requests_prep;;
    pull-requests-gen) shift; pull_requests_gen "$@";;
    help) dev_help;;
    release) current_release;;
    releases) show_releases;;
    cut_release) shift; cut_release "$@";;
    switch) shift; switch_release "$@";;
    *) dev_help ; die "Unknown command $1.  Please use \"help\" for help.";;
esac

